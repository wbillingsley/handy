Handy
====

These are some small simple solutions to common problems, particularly in Scala web apps.  

There are (obviously) occasions when bigger solutions, or the solutions built into large standard frameworks, are a good idea.  But often I find it's more productive and clearer to quickly develop and experiment with something small and fast, using clear little standalone solutions like these   

Ref
---

Ref is for passing around references to database objects that might not have been looked up yet, and might not exist, or otherwise might fail when the look-up is resolved.

It takes its inspiration from Option and Lift's Box.  Its subclasses (mostly case classes) can contain an item, a key to an item, a reference to nothing, or can represent a failure to look an item up.

It can be converted into an Option simply

val ref = RefByKey(classOf[Doohickey], key)
val itMightNotBeThere = ref.toOption

Refs to other items can be obtained simply

val otherRef = ref.flatMap(RefItself(_.otherThing))
val otherRef = ref.flatMap(RefByKey(classOf[OtherThing], _.otherThingId))

etc


Sec
---

Sec is a simple security idiom.  Most calls are of the form
 
val perm = Sec.may(SomeAction(resourceRef), permTok) 
if (perm.may) {
 ...
} else {
 ... do something with perm.reason
}

It's designed so that we can keep calling perm.may with different operations, and the granted permissions are remembered.  This lets us pass the permTok around our API to other methods that might re-ask for the same permission without worrying about it doing a second look-up.

The operations are case classes defined by the app, with resolution defined by the app.